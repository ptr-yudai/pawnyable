---
title: 制約付きシェルコード
date: 2022-02-05 11:09:00
tags:
    - [Linux]
    - [Userland]
    - [shellcode]
lang: ja
---
CTFではしばしば制約付きシェルコード問題が出題されます。さまざまな制約がありますが、ここでは実世界のExploitでも役に立ちそうなものだけ解説します。

<div class="column" title="目次">
<!-- toc --><br>
</div>

## 長さ制約付きシェルコード
シェルコードの長さに制約があるという状況は少なからず起こります。どのように長さ制限を突破できるでしょうか

### 短い機械語の選択
長さ制限があるとき、同じ処理ができるなら短い機械語の方がお得です。まずはx86-64でバイト長が短い命令について知っておきましょう。

#### レジスタのクリア・代入
シェルコードで頻出なのがレジスタを0にする命令です。
```
xor eax, eax
xor edx, edx
```
のように32-bitレジスタに対してXORを使うと、レジスタの64-bitまるごと0になります。32-bitで計算すれば命令長は2バイトです。ただし、レジスタがr12などの場合はr12dにしても3バイトです。

もしeax,edxレジスタの両方を空にしたいのであれば、`cdq`命令でeaxをedx:eaxに拡張すると3バイトに収まります。
```
xor eax, eax
cdq
```

また、0以外のデータでもレジスタ間で値をコピーしたい場合は、`push`/`pop`命令も便利です。
```
push rax
push rax
pop rdx
pop rcx
```
それぞれ1バイトなので、`mov`命令を使うよりも短く済みます。

#### ポインタの取得
次に文字列ポインタを取得する場合を考えます。多くの場合、次のように`call`命令を使うのが短いです。
```
call X
db "Hello", 0
X:
pop rdi
```
`call`命令に5バイト、`pop`命令に1バイト必要になります。

#### データのコピー
文字列などのバイトデータの扱いは`rep`系命令と`movs`, `cmps`, `scas`, `lods`, `stos`命令を組み合わせることで短く実現できます。
`rep`命令はrcxが0になるまで後続の命令を繰り返すことができるプレフィックスです。例えば`memcpy(rdi, rsi, rdx);`は次のように書けます。
```
push rdx
pop rcx
rep movsb
```

<div class="balloon_l">
  <div class="faceicon"><img src="../img/piyo.jpg" alt="ひよこ先生" ></div>
  <p class="says">
    このシェルコードはフラグレジスタのディレクションフラグ（ストリング操作命令実行後にrsi,rdiをインクリメントするかデクリメントするかを決めるフラグ）が0であると仮定しているため、厳密には正しくないよ。長さに余裕があるときな必ずループの前に`cld`命令を置くように心がけてね。
  </p>
</div>

別の例として、次の関数をなるべく短く機械語で書いてみましょう。
```c
void mystrcpy(char *dst, const char *src) {
  while (1) {
    *p1++ = *p2;
    if (*p2 == 0) break;
    p2++;
  }
}
```
GCCに`-Os`フラグを渡すと次のようになりました。
```
00000000000011d9 <mystrcpy>:
    11d9:       f3 0f 1e fa             endbr64 
    11dd:       31 c0                   xor    eax,eax
    11df:       8a 14 06                mov    dl,BYTE PTR [rsi+rax*1]
    11e2:       88 14 07                mov    BYTE PTR [rdi+rax*1],dl
    11e5:       48 ff c0                inc    rax
    11e8:       80 7c 06 ff 00          cmp    BYTE PTR [rsi+rax*1-0x1],0x0
    11ed:       75 f0                   jne    11df <mystrcpy+0x6>
    11ef:       c3                      ret 
```
`endbr64`を除けば19バイトになります。ストリング操作命令を使うと次のようになります。
```
mystrcpy:
  .@Lp:
  lodsb
  stosb
  test al, al
  jnz .@Lp
  ret
```
たったの7バイトになりました。`cld`命令を入れても8バイトです。コンパイラは事前に与えられた規則にしたがってしか最適化できないので、状況に応じて自分でシェルコードを書くと短いコードが書けます。

<div class="balloon_l">
  <div class="faceicon"><img src="../img/piyo.jpg" alt="ひよこ先生" ></div>
  <p class="says">
    GCC恐るるに足らず
  </p>
</div>

また、`loop`命令を使うとrcxの値だけループできるため、`cmp`と`jmp`系命令を使うよりも短く書ける場合もあります。

### Stagerの構築
長さ制限をクリアできない場合はシェルコードを多段階に分けるのが一般的です。

#### readの利用
シェルコード実行時に攻撃対象のプログラムにデータを送る手段が残っている場合は、readシステムコールなどを利用します。例えば次のように別の実行可能かつ書き込み可能な領域にシェルコードを上書きします。
```
mov edx, 0x1000
lea rsi, [rel stage2]
xor edi, edi
xor eax, eax
syscall
jmp rsi
```
シェルコードを実行している箇所が書き込み可能な場合、そこに直接書き込んで`syscall`命令から2段階目のシェルコードを開始しても良いです。（ジャンプ命令が不要になるので短く済みます。）

また、一般的には標準入力からデータを送ることはできないため、reverse shellの要領でソケット経由でシェルコードを送る方法もあります。

#### Egg Hunterの利用
標準入力が使えないからといってソケットを利用すると、今度はシェルコードが大きくなってしまいます。また、後の章で登場するseccompによりソケット通信が禁止されている場合もあります。
このような場合、事前にヒープなどにシェルコード本体を置いておき、1段階目のシェルコードでそれを見つけてロード・実行するという方法が使えます。これを**Egg Hunter**と呼びます。シェルコードには目印となるようなバイト列を先頭などに設置し、それをEgg Hunterが探索します。Egg Hunterについては詳しく後の章で説明するので、ここでは解説しません。

## 文字制約付きシェルコード
CTFにおいては特定の言語の文字だけを利用したり、使えるバイトが数種類だけだったりという制約付きシェルコードが出題されますが、そのような状況は実際にはありえないと言って良いでしょう。ここでは現実的に起こり得る文字制約について考えます。

### NULL文字、改行文字制約
実際にはあまり見ませんが、strcpyの利用や入力の問題でNULL文字や改行文字が使えない場合があります。こういった場合はxorなどを使って適当にデータを書き換えれば問題ありません。
また、例えば
```
call arg0
db "/bin/sh", 0
arg0:
pop rdi
```
のように書くと`call`命令のジャンプ先オフセットがscanfなどの受け付けない文字になってしまいます。このような場合はデータを増やして適当にオフセットを調節しましょう。

### ASCII / UTF-8文字制約
あまりCTFなどでは見かけませんが、実際に起こり得るのがUTF-8文字制約シェルコードです。文字列の処理系が絡んでいるとき、例えば"\x80"のようなデータを使うと"\xc2\x80"に変換されてしまうことがあります。
このような場合、0x00から0x7FまでのASCII文字を使うのが簡単な解決策でしょう。

このような制約付き問題では、命令は[x86-64の命令テーブル](http://ref.x86asm.net/coder64.html)などを参考に見つけましょう。制約が厳しい場合はPythonなどで命令を探すスクリプトを書くのも有効な手段です。

今回、レジスタの値の調整には次のような命令が使えます。
```
04 ZZ             add al, imm8
66 05 XX XX       add ax, imm16
05 XX XX XX XX    add eax, imm32
```
また、レジスタの値を0にするには次のような命令列が使えます。
```
52             push rdx
48 33 14 24    xor rdx, [rsp]
```
システムコールはそのまま使えます。
```
0f 05    syscall
```
値の移動やスタックの変更には次のような命令が使えます。
```
50             push rax
58             pop rax
52             push rdx
5a             pop rdx
51             push rcx
59             pop rcx
34 XX          xor al, imm8
30 44 24 XX    xor [rsp+imm8], al
6b 04 24 05    imul eax, [rsp], 5
33 44 24 XX    xor eax, [rsp+imm8]
```
このような命令はいくらでも見つかるので、十分に自由な操作が実現できます。

### 浮動小数点(IEEE 754)制約
あまり問題にはなりませんが、JavaScript Exploitなどの文脈ではシェルコードを浮動小数点配列の形で与えることがあります。頻繁には起こりませんが、シェルコードが偶然NaNなどの複数通り表現がある形や、IEEE 754では起こりえないバイト列になってしまう可能性があります。
浮動小数点でシェルコードを与えて書き込めていない場合、浮動小数点で表せる形になっているかを確認しましょう。nop命令などを入れてデータをずらすことで解決できます。

## 状態制約付きシェルコード
何の制約もなくシェルコードを書き込めたとしても、シェルコード実行時に問題が起きる可能性があります。

### アドレスが分からない場合
シェルコードが実行できても自分自信のアドレスが分からない場合があります。通常シェルコードが実行される際に、そのシェルコードのアドレスがレジスタにロードされ、そこへジャンプします。しかし、ジャンプ後に必ず何らかの処理が実行されてしまう場合、シェルコードのアドレスを持つレジスタが破壊される可能性があります。
アドレスが分からない場合、Stagerの実行が困難になるといった問題が発生します。このような場合、call命令かシステムコールを利用できます。
call命令は簡単で、スタックにリターンアドレスが積まれることを利用してRIPを取り出します。これはコンパイラが生成するコードにも登場するような、一般的な手法です。
```
  call x
x:
  pop rax ; rax=<address of `pop rax`>
```
次にシステムコールです。Linuxにおいて、syscall命令は戻りアドレスをrcxレジスタに入れるという特性があります。したがって、次のように何もしないシステムコールを実行すれば`syscall`命令の次のアドレスを取得できます。
```
xor esi, esi
xor eax, eax
syscall    ; read(?, NULL, ?) （悪影響のないシステムコールが動けば何でも良い）
```
また、シェルコードではなくlibcやヒープ、スタックなどのアドレスが必要な場合、TLS領域の情報を利用できます。
64-bitのLinuxでは3つのスレッド固有領域（**TLS**; Thread Local Storage）があり、そのうち2つはfsレジスタとgsレジスタでアクセス可能です。TLSにはcanaryなどの情報があり、スタックへのポインタも保持しています。例えばglibcがロードされているとき、次のようなシェルコードでスタックのアドレスを取得できます。
```
mov rax, [fs:0x300]
```
オフセットはバージョンにより異なる可能性があるので、適宜gdbで確認してください。

### シェルコード領域が書き込み不能の場合
シェルコードを`/proc/self/mem`経由で書き込んだ場合や、Bring Your Own Gadgetで動かす場合などは、シェルコード領域が実行可能でも書き込み不能の場合があります。一般にシェルコードを動的に書き換えることはありませんが、エンコーダなどを利用している場合はシェルコードを書き換える必要があります。
このような場合、シェルコードを書き換えるよりもROPに持ち込んだ方が簡単な場合が多いです。シェルコードが書き込めている以上ROP gadgetも書き込めるので、スタックにgadgetのアドレスを積んで`ret`命令を呼べばROPが可能です。

----

<div class="column" title="例題１">
  すべての汎用レジスタが0xdeadbeefcafebabeの状態から<code>/bin/sh</code>を起動するシェルコードを24バイト以内で書け。ただし、シェルコード領域は書き換え不可能とする。（汎用レジスタはRSPやRBPも含む。）
</div>
<div class="column" title="例題２">
  0x00から0x7Fまでのバイト列のみを使って「ls -lha」を実行するシェルコードを書け。ただし、シェルコード領域は書き込み不能とする。また、RSPは正常なスタックポインタを指しているが、それ以外のレジスタやスタック上のデータの初期状態はランダムと仮定する。
</div>

[☞ 例題の解答](restricted-answer.html)
