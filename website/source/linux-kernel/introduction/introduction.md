---
title: カーネルexploitへの導入
date: 2021-09-22 14:04:55
tags:
    - [Linux]
    - [Kernel]
lang: ja
---
「ユーザーランドのpwnは一通り勉強したけど、カーネルからは難しそうで手が出ない」という方は多いでしょう。しかし実はカーネルexploitは場合によっては非常に攻撃が簡単です。
この節では、ユーザーランドexploitとカーネルexploitとの違い、環境構築などについて説明します。

<div class="column" title="目次">
<!-- toc --><br>
</div>

## カーネルexploitの特徴
まず始めにユーザーランドと比べてカーネル空間の脆弱性にはどんな特徴があるかを知っておきましょう。

### 攻撃対象
ユーザーランドexploitとカーネルexploitの最も大きな違いはその目的にあります。
これまで説明したユーザーランドexploitでは多くの場合「任意コマンド実行」という目標に向けてexploitを書きました。一方で、カーネルexploitでは「権限昇格」に向けてexploitを書きます。カーネルexploitは、何らかの手段で攻撃対象のマシンに侵入できた仮定で、さらにroot権限を取得するための攻撃です。この権限昇格のことを**LPE**(Local Privilege Escalation)と呼びます。

ユーザーランドexploitでももちろん権限昇格できる脆弱性もありますが、それは攻撃対象のプログラムが特権ユーザーで動作しているからです。カーネルexploitの場合、攻撃対象は主に2つあります。

1. Linuxカーネル
2. カーネルモジュール

Linuxカーネル中のコードは必ずroot権限で動作しているため、カーネルそのものにバグがある場合LPEに繋がる可能性があります。
もう1つはデバイスドライバなどのカーネルモジュールに含まれる脆弱性です。デバイスドライバは、ユーザー空間から主に外部機器（プリンタなど）とのやりとりを簡単にするためのインタフェースです。デバイスドライバも必ずroot権限で動作している[^1]ので、バグがある場合LPEに繋がります。

### 攻撃方法
通常ユーザーランドexploitの場合、特定のサービスに対して入力を与えることでexploitしました。そのためPythonなどの言語でexploitを書くのが主流です。
一方カーネルexploitの場合、対象はOSやドライバです。これらは低レイヤのため、C言語などでexploitを書くのが主流です。もちろんPythonなどでも書けますが、そもそも攻撃対象のマシン（特にCTFや実験環境で用意されるような小さいLinux）の上にPythonが存在することが少ないため、動かない可能性が高いです。

このサイトでもexploitをC言語で記述します。詳しい話は別の節で出てきますが、[musl-gcc](https://www.musl-libc.org/)というコンパイラを使います。

### リソースの共有
もう1つの特徴は、リソースが共有されているという点です。
ユーザーランドでは通常、攻撃対象のプロセスが1つ存在し、そのプロセスをexploitすることでシェルを取るなどしました。一方で、Linuxカーネルやデバイスドライバといったプログラムはユーザー全員に共有されています。システムコールは誰でも自由なタイミングで使うことが可能ですし、デバイスドライバも誰がいつ操作するかわかりません。つまり、ドライバを書く際は常にマルチスレッドのつもりでプログラミングしなければ簡単に脆弱性を埋め込んでしまいます。

<div class="balloon_l">
  <div class="faceicon"><img src="../img/cow.jpg" alt="牛さん" ></div>
  <p class="says">
    グローバル変数のように競合する可能性のあるデータを使うときはロックを取らないといけないってことだね。ドライバのプログラミングって大変だ〜。
  </p>
</div>

### ヒープ領域の共有
さらに、カーネルのヒープは全ドライバやカーネルで共有されているという大きな特徴があります。
これまでユーザーランドのexploitでは、プログラムごとにヒープがあるため、そのプログラムでHeap Overflowが起きたからといってexploitableかはプログラム依存でした。しかし、例えばデバイスドライバで1回ヒープオーバーフローが起きると、他のデバイスドライバやLinuxカーネルがヒープに確保した周辺のデータまで汚染されてしまいます。
攻撃者の観点からすると、この特徴には長所と短所があります。長所は、ヒープ周りの小さな脆弱性でもLPEに繋がる可能性が非常に高いという点です。例えば関数ポインタを持つオブジェクトはLinuxカーネルにたくさん存在するので、そのどれかを利用してRIPが簡単に取れるわけです。一方で短所は、全プログラムの影響を受けるためヒープの状態が予測できないという点です。ユーザーランドのプログラムは簡単なものであれば、入力に対してヒープの状態が決定的だったので、複雑なヒープexploit（俗に言うHouse of XXXなど）が可能でした。一方カーネルではHeap Overflowが発生するチャンクの後ろにどんなデータが来るかや、Use-after-Freeでfreeされた後に誰がそのアドレスを使うかはわかりません。

<div class="balloon_l">
  <div class="faceicon"><img src="../img/cow.jpg" alt="牛さん" ></div>
  <p class="says">
    ということは、カーネルexploitではHeap Sprayが頻出なんだね。
  </p>
</div>

脆弱性自体はユーザーランドのものと大きく変わりません。Stack OverflowやUse-after-Freeなどはカーネルランドにも存在し得ます。また、デバイスドライバのスタックにもセキュリティ機構としてStack Canaryを置くことができます。ただし、カーネル空間特有の脆弱性というのもあるので、それは後の節で登場します。

## qemuの利用
Linuxカーネルexploitを書くときはデバッグのためにエミュレータの上でカーネルを動かします。VMなら何でも構いませんが、qemuが一般的なのでこのサイトでもqemuを利用します。

読者の方は自分の環境に合わせてqemu-systemをインストールしておいてください。
```
# apt install qemu-system
```

## ディスクイメージ
qemuでマシンを起動する際、Linuxカーネルとは別にルートディレクトリとしてマウントされるディスクイメージが必要です。
ディスクイメージは一般的にext等のファイルシステムの生バイナリか、cpioと呼ばれる形式で作成・配布されます。
ファイルシステムの場合はmountコマンドでマウントすれば中のファイルを編集できます。
```
# mkdir root
# mount rootfs.img root
```

このサイトで扱う演習では、CTFで一般的であり、また軽量であるcpio形式を使います。
cpioコマンドを使って次のようにファイルを展開します。
```
# mkdir root
# cd root; cpio -idv < ../rootfs.cpio
```
ファイルを追加したり編集したら、次のように再びcpioファイルにまとめます。
```
# find . -print0 | cpio -o --format=newc --null > ../rootfs_updated.cpio
```
cpioがさらにgzで圧縮されている場合もあるので、そのような際は適宜展開・再圧縮してください。


[^1]: ファイルシステムやキャラクタデバイスは通常カーネルモジュールで実装されますが、[FUSE](https://lwn.net/Articles/796674/)や[CUSE](https://lwn.net/Articles/308445/)といった機能の登場により、ユーザー空間からも実装できるようになりました。

----

<div class="column" title="例題">
  <a href="../LK01/distfiles/LK01.tar.gz">練習問題LK01</a>のファイルをダウンロードして以下の操作を実行しましょう。<br>
  (1) <code>run.sh</code>を実行して、Linuxが立ち上がることを確認してください。<br>
  (2) 起動時にシェルがroot権限になるように<code>rootfs.cpio</code>を編集してください。（ヒント：起動時のメッセージを表示しているスクリプトを探しましょう。）
</div>
